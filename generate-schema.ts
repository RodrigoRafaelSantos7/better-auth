// Generate schema for src/component/schema.ts
// To regenerate the schema, run:
// npx tsx generate-schema.ts
import { getAuthTables, type FieldAttribute } from "better-auth/db";
import { writeFileSync } from "fs";
import { inactiveFields, indexFields } from "./src/auth";
import { argv } from "process";
import path from "path";

if (!argv[2]) {
  throw new Error("Auth path is required");
}

if (!argv[3]) {
  throw new Error("Output path is required");
}

const authPath = path.resolve(argv[2]);
const outputPath = path.resolve(argv[3]);

const { authWithoutCtx: auth } = await import(authPath);

const tables = getAuthTables(auth.options);
const specialFields = Object.fromEntries(
  Object.entries(tables)
    .map(([key, table]) => {
      const fields = Object.fromEntries(
        Object.entries(table.fields)
          .map(([fieldKey, field]) => [
            fieldKey,
            {
              ...(field.sortable ? { sortable: true } : {}),
              ...(field.unique ? { unique: true } : {}),
              ...(field.references ? { references: field.references } : {}),
            },
          ])
          .filter(([_key, value]) =>
            typeof value === "object" ? Object.keys(value).length > 0 : true
          )
      );
      return [key, fields];
    })
    .filter(([_key, value]) =>
      typeof value === "object" ? Object.keys(value).length > 0 : true
    )
);

const mergedIndexFields = Object.fromEntries(
  Object.entries(tables).map(([key]) => {
    const manualIndexes = indexFields[key as keyof typeof indexFields] || [];
    const specialFieldIndexes = Object.keys(
      specialFields[key as keyof typeof specialFields] || {}
    ).filter(
      (index) =>
        !manualIndexes.some((m) =>
          Array.isArray(m) ? m[0] === index : m === index
        )
    );
    return [key, manualIndexes.concat(specialFieldIndexes)];
  })
);

let code: string = `// This file is auto-generated from auth.ts by generate-schema.ts. Do not edit this file manually.
// To regenerate the schema, run:
// npx tsx generate-schema.ts

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export const tables = {
`;

for (const tableKey in tables) {
  const table = tables[tableKey]!;
  const modelName = table.modelName;

  // No id fields in Convex schema
  const fields = Object.fromEntries(
    Object.entries({
      ...table.fields,
      ...(inactiveFields[tableKey as keyof typeof inactiveFields] || {}),
    }).filter(([key]) => key !== "id")
  );

  function getType(name: string, field: FieldAttribute) {
    const type = field.type as
      | "string"
      | "number"
      | "boolean"
      | "date"
      | `${"string" | "number"}[]`;

    const typeMap: Record<typeof type, string> = {
      string: `v.string()`,
      boolean: `v.boolean()`,
      number: `v.number()`,
      date: `v.number()`,
      "number[]": `v.array(v.number())`,
      "string[]": `v.array(v.string())`,
    } as const;
    return typeMap[type];
  }

  const indexes =
    mergedIndexFields[modelName as keyof typeof mergedIndexFields]?.map(
      (index) => {
        const indexArray = Array.isArray(index) ? index.sort() : [index];
        const indexName = indexArray.join("_");
        return `.index("${indexName}", ${JSON.stringify(indexArray)})`;
      }
    ) || [];

  const schema = `${modelName}: defineTable({
${Object.keys(fields)
  .map((field) => {
    const attr = fields[field]!;
    const type = getType(field, attr as FieldAttribute);
    const optional = (fieldSchema: string) =>
      attr.required
        ? fieldSchema
        : `v.optional(v.union(v.null(), ${fieldSchema}))`;
    return `    ${field}: ${optional(type)},`;
  })
  .join("\n")}
  })${indexes.length > 0 ? `\n    ${indexes.join("\n    ")}` : ""},\n\n`;
  code += `  ${schema}`;
}

code += `};

const schema = defineSchema(tables);

export default schema;
`;

// export map of unique, sortable, and reference fields
code += `export const specialFields = ${JSON.stringify(
  specialFields,
  null,
  2
).replace(/"([^"]+)":/g, "$1:")};\n`;

// write code to file
writeFileSync(outputPath, code);
